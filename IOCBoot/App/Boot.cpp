/***********************************************************************/
/*                                                                     */
/*  FILE        :Boot.cpp                                              */
/*  DATE        :Wed, Sep 18, 2002                                     */
/*  DESCRIPTION :Main Program                                          */
/*  CPU TYPE    :H8S/2633F                                             */
/*                                                                     */
/*  This file is generated by Hitachi Project Generator (Ver.1.1).     */
/*                                                                     */
/***********************************************************************/
                  
#include "machine.h" 
#include "CodeOpt.h"
#include "DataType.h"
#include "iodefine.h"
#include "g_cmx.h"
#ifndef CXFUNCS_H_05_05_2009
#define CXFUNCS_H_05_05_2009
#include "CxFuncs.h"
#endif
#include "sci.h"
#include "Debug.h"
// #include "Amd29.h" 
#include "Amd29DL161DB.h"
#include "AllProcess.h"
#include "stdio.h" 
#include "RTC.h"
#include "ConstDef.h"

EXTERN void StartCMX(void)
{               
	set_exr(7);
	g_cmx_started = 1; 
	K_OS_Start();			/* enter CMX RTOS */
	
}

#if RUN_IN_ROM  
EXTERN void LoadRAMVect(void);
#endif                              

// Return 1 for pass
// -1 data error
// -2 address error
EXTERN int CheckRam(unsigned long start, unsigned long len, int8 bStrict)
{            
	register uint16 volatile *wPtr;
	const uint16 *pattern_list;
	volatile uint16 pattern;
	register int pattern_size;
	unsigned long adr;
	long i;
	unsigned long cnt;
	unsigned long end = start + len;
	volatile uint16 j;
	volatile uint16 tmp16;

#define TOTAL_PATTERN_SIZE (20+16)
#define PATTERN_SIZE 4

	static const uint16 data_pattern[TOTAL_PATTERN_SIZE] = {
	0x0, 0xa5a5, 0x5a5a, 0xffff,  
	0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
	0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000,
	~0x1, ~0x2, ~0x4, ~0x8, ~0x10, ~0x20, ~0x40, ~0x80,
	~0x100, ~0x200, ~0x400, ~0x800, ~0x1000, ~0x2000, ~0x4000, ~0x8000
	};

	set_exr(7); //DISABLE_INTR;
	
	// Check Data bus
	pattern_list = data_pattern;
	wPtr = (uint16 *)start;
	for (i = 0; i < TOTAL_PATTERN_SIZE; i++) {
		pattern = *(pattern_list++);
		*wPtr = pattern;
		tmp16 = *(wPtr+1); // Clear data bus
		if (*wPtr != pattern) {
#if RUN_IN_ROM
			LoadRAMVect();
#endif
			return -1;
		}
	}

	// Check content
	pattern_list = data_pattern;
	pattern_size = (bStrict) ? (TOTAL_PATTERN_SIZE) : (PATTERN_SIZE);
	start &= 0xfffffe;
	len &= 0xfffffe;
	wPtr = (uint16 *)start;
	for (wPtr = (uint16 *)start; wPtr < (uint16 *)end; wPtr++) {
		pattern_list = data_pattern;
		for (i = 0; i < pattern_size; i++) {
			pattern = *(pattern_list++);//data_pattern[i];
			*wPtr = pattern;
			//tmp16 = *(wPtr + 1); // Clear data bus
			if (*wPtr != pattern) {    
#if RUN_IN_ROM
				LoadRAMVect();
#endif			
				return -1;
			}
		}
	}
	
	// Clear all the memory;
	for (wPtr = (uint16 *)start; wPtr < (uint16 *)end; wPtr++) {
		*wPtr = 0;
	}
	
	// Check address lines
	j = 1;
	adr = 2; cnt = j;
	*((uint16 *)start) = j;
	while (adr < len) {
		wPtr = (uint16 *)(start + adr);
		*wPtr = j;
		cnt += j;
		j++;
		adr <<= 1;
	};
	register unsigned long sum = 0;
	for (wPtr = (uint16 *)start; wPtr < (uint16 *)end; wPtr++) {
		sum += (unsigned long)(*wPtr);		
	}
	if (cnt != sum) {
#if RUN_IN_ROM
		LoadRAMVect();
#endif	
		return -2;
	}

	// Clear all the memory;
	for (wPtr = (uint16 *)start; wPtr < (uint16 *)end; wPtr++) {
		*wPtr = 0;
	}

#if	RUN_IN_ROM
	LoadRAMVect();
#endif
	return 1;
} 
                              
EXTERN void Fatal(const char *pStr)
{              
	// Don't use heap
    CCheapTimer Timer1;
    CCheapTimer Timer2;     
    CPVOperation PV1;
    CPVOperation PV2; 
#if ENABLE_SCI0    
	CSci sci(SCI0_REG, &Timer1, &PV1, DEFAULT_BAUD0);
#else 
    CSci sci(SCI1_REG, &Timer1, &PV1, DEFAULT_BAUD1);
#endif    
    CDebug debugger;
    
    //CAmd29lv800bb flash(0x800000, &Timer2, &PV2);
    CAmd29DL161DB flash(0x800000, &Timer2, &PV2);
    
	//g_pSci1 = &sci1;	
	INTC.IPRK.BIT.HIGH = 0;       
	set_exr(7);               
	
	// sci.ForceSend("\r\nFailed mode:");
	sci.ForceSend(pStr); 
	sci.ForceSend("Running in Failed mode\r\n");
	debugger.Start(&sci, &flash, 1);
		
#if 0
	// Use heap
	CDebug *pDebug;
	CAmd29lv800bb *pFlash;

    sci1_init();
    if (g_pSci1 == NULL) {
    	sleep();
    	return;
    }
	pDebug = new CDebug();
	pFlash = new CAmd29lv800bb(0x800000);
	set_exr(7);  
	g_pSci1->ForceSend("\r\nRAM check failed\r\n");
	pDebug->Start(g_pSci1, pFlash, 1);   
#endif	
}

EXTERN void ClearRam(void)
{              
	register uint16 volatile *wPtr = (uint16 *)0x200000;
	register uint32 length = 0x200000 >> 1; 
	register uint32 i;
#if RAM_2M_BYTE
	for (i = 0; i < length; i++) {
		*wPtr++ = 0;
	}
#endif
}

EXTERN void RAMFail(void)
{   
	Fatal("\r\nRAM CHECK FAILED\r\nCMX not started\r\n");
}         

EXTERN void VerifyRAM(void)
{
	int ret = 0;
#if RUN_IN_ROM

#if RAM_2M_BYTE
    ret = CheckRam(0x200000, 0x200000, 0);
#elif RAM_1M_BYTE
	ret = CheckRam(0x200000, 0x100000, 0);  
#else  // RAM_1M_BYTE
	ret = CheckRam(0x200000, 0x80000, 0);
#endif // RAM_1M_BYTE

#endif //RUN_IN_ROM

#if RUN_IN_RAM
	ret = CheckRam(0x240000, 0x10000, 0);
#endif

#if 0 // Make this 1 to have the option to stop CMX
	if ((ret == 1) && ((P7.PORT.BYTE & 8) == 0) /*SW2-1 is on*/){
		Fatal("RAM test passed!. Forced failure\r\n");
		sleep();
	}
#endif
	
	if (ret != 1) {
		// RAM error, start debugger without OS
		RAMFail();
		sleep();
	}
	//RAMFail();
}

EXTERN int PassCheckSum(unsigned long *sumH, unsigned long *sumL);

EXTERN void VerifyROM(void)
{       
	char buff[100];
	int ret;
    unsigned long chkH, chkL;
    
	ret = PassCheckSum(&chkH, &chkL);
	if (ret <= 0) { 
		sprintf(buff, "ROM Checksum[%d] failed[H:%08lX L:%08lX]\r\n", ret, chkH, chkL);
		Fatal(buff);
		sleep();
	}                     
	 
}	   
#if 0                          
static void test01(void)
{      
    char buff[100];  

	set_exr(0); 
	for (int i = 0; i < 10; i++) {
		if (g_pSci1) {
			sprintf(buff, "Test%04d\r\n", i);
			g_pSci1->Send(buff);
		}		
	}   
	if (g_pSci1) {
		g_pSci1->ForceSend("End of test\r\n");
	}
}
#endif
        
extern unsigned long g_nextBlock;


EXTERN void main(void)
{    
	int ret;
	            
	set_exr(7);
    	
	// Hardware OK, start CMX
	K_OS_Init();	 /* initialize ram and things */  
	{
		// 3/12/2008 zmiao: Don't clear it to catch repeated abnormal reset such as watchdog fire.
		//extern volatile unsigned long g_systemTicks; 
		//g_systemTicks = 0L;
	}
	g_pAll = new CAllProcess();
	g_pAll->StartAll(g_nextBlock);
	set_exr(0); 
	// test01();	
	StartCMX();
}
